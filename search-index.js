var searchIndex={};
searchIndex["probabilistic_collections"] = {"doc":"probabilistic-collections-rs","i":[[3,"SipHasherBuilder","probabilistic_collections","The default hash builder for all collections.",null,null],[0,"bit_array_vec","","Growable list of bit arrays.",null,null],[3,"BitArrayVec","probabilistic_collections::bit_array_vec","A growable list of bit arrays implemented using a `Vec<u8>`.",null,null],[3,"BitArrayVecIter","","An owning iterator for `BitArrayVec`.",null,null],[3,"BitArrayVecIntoIter","","An iterator for `BitArrayVec`.",null,null],[11,"new","","Constructs a new `BitArrayVec` with a certain number of…",0,[[["usize"]],["self"]]],[11,"from_elem","","Constructs a new `BitArrayVec` with a certain number of…",0,[[["usize"]],["self"]]],[11,"with_capacity","","Constructs a new, empty `BitArrayVec` with a certain…",0,[[["usize"]],["self"]]],[11,"set","","Sets the value at index `index` to `bytes`.",0,[[["self"],["usize"]]]],[11,"get","","Returns the value at index `index`.",0,[[["self"],["usize"]],[["vec",["u8"]],["u8"]]]],[11,"truncate","","Truncates a `BitArrayVec`, dropping excess elements.",0,[[["self"],["usize"]]]],[11,"reserve","","Reserves capacity for at least `additional` more bit…",0,[[["self"],["usize"]]]],[11,"reserve_exact","","Reserves capacity for at least `additional` more bit…",0,[[["self"],["usize"]]]],[11,"pop","","Returns and removes the last element of the `BitVecArray`.",0,[[["self"]],[["vec",["u8"]],["u8"]]]],[11,"push","","Pushes an element into the `BitArrayVec`.",0,[[["self"]]]],[11,"clear","","Clears all elements in the `BitVecArray`, setting all bit…",0,[[["self"]]]],[11,"iter","","Returns an iterator over the elements of the vector in…",0,[[["self"]],["bitarrayveciter"]]],[11,"capacity","","Returns the capacity of the `BitArrayVec`.",0,[[["self"]],["usize"]]],[11,"len","","Returns the number of elements in the `BitArrayVec`.",0,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the `BitArrayVec` is empty.",0,[[["self"]],["bool"]]],[11,"occupied_len","","Returns the number of non-zero elements in the…",0,[[["self"]],["usize"]]],[11,"bit_count","","Returns the number of bits in each bit array stored by the…",0,[[["self"]],["usize"]]],[0,"bit_vec","probabilistic_collections","Growable list of bits.",null,null],[3,"BitVec","probabilistic_collections::bit_vec","A growable list of bits implemented using a `Vec<u8>`",null,null],[3,"BitVecIter","","An owning iterator for `BitVec`.",null,null],[3,"BitVecIntoIter","","An iterator for `BitVec`.",null,null],[11,"new","","Constructs a new `BitVec` with a certain number of bits.…",1,[[["usize"]],["self"]]],[11,"from_elem","","Constructs a new `BitVec` with a certain number of bits.…",1,[[["usize"],["bool"]],["self"]]],[11,"from_bytes","","Constructs a `BitVec` from a byte slice. Each byte becomes…",1,[[],["self"]]],[11,"to_bytes","","Returns the byte-vec representation of the `BitVec` with…",1,[[["self"]],[["vec",["u8"]],["u8"]]]],[11,"with_capacity","","Constructs a new, empty `BitVec` with a certain capacity.",1,[[["usize"]],["self"]]],[11,"set","","Sets the value at index `index` to `bit`.",1,[[["self"],["usize"],["bool"]]]],[11,"get","","Returns the value at index `index`, or `None` if index is…",1,[[["self"],["usize"]],[["bool"],["option",["bool"]]]]],[11,"set_all","","Sets all values in the `BitVec` to `bit`.",1,[[["self"],["bool"]]]],[11,"flip","","Flip the value at index `index`.",1,[[["self"],["usize"]]]],[11,"flip_all","","Flips all values in the `BitVec`.",1,[[["self"]]]],[11,"union","","Sets `self` to the union of `self` and `other`.",1,[[["self"],["self"]]]],[11,"intersection","","Sets `self` to the intersection of `self` and `other`.",1,[[["self"],["self"]]]],[11,"difference","","Sets `self` to the difference of `self` and `other`.",1,[[["self"],["self"]]]],[11,"symmetric_difference","","Sets `self` to the symmetric difference of `self` and…",1,[[["self"],["self"]]]],[11,"truncate","","Truncates a `BitVec`, dropping excess elements.",1,[[["self"],["usize"]]]],[11,"reserve","","Reserves capacity for at least `additional` more bits to…",1,[[["self"],["usize"]]]],[11,"reserve_exact","","Reserves capacity for exactly `additional` more bits to be…",1,[[["self"],["usize"]]]],[11,"pop","","Returns and removes the last element of the `BitVec`.…",1,[[["self"]],[["bool"],["option",["bool"]]]]],[11,"push","","Pushes an element into the `BitVec`.",1,[[["self"],["bool"]]]],[11,"iter","","Returns an iterator over the elements of the vector in…",1,[[["self"]],["bitveciter"]]],[11,"is_empty","","Returns `true` if the `BitVec` is empty.",1,[[["self"]],["bool"]]],[11,"len","","Returns the number of elements in the `BitVec`.",1,[[["self"]],["usize"]]],[11,"capacity","","Returns the capacity of the `BitVec`.",1,[[["self"]],["usize"]]],[11,"count_ones","","Returns the number of set bits in the `BitVec`.",1,[[["self"]],["usize"]]],[11,"count_zeros","","Returns the number of unset bits in the `BitVec`.",1,[[["self"]],["usize"]]],[0,"bloom","probabilistic_collections","Space-efficient probabilistic data structure for…",null,null],[3,"BloomFilter","probabilistic_collections::bloom","A space-efficient probabilistic data structure to test for…",null,null],[3,"BSBloomFilter","","A space-efficient probabilistic data structure for data…",null,null],[3,"BSSDBloomFilter","","A space-efficient probabilistic data structure for data…",null,null],[3,"RLBSBloomFilter","","A space-efficient probabilistic data structure for data…",null,null],[3,"PartitionedBloomFilter","","A space-efficient probabilistic data structure to test for…",null,null],[3,"ScalableBloomFilter","","A growable, space-efficient probabilistic data structure…",null,null],[11,"new","","Constructs a new, empty `BloomFilter` with an estimated…",2,[[["f64"],["usize"]],["self"]]],[11,"from_item_count","","Constructs a new, empty `BloomFilter` with `bit_count`…",2,[[["usize"]],["self"]]],[11,"from_fpp","","Constructs a new, empty `BloomFilter` with `bit_count`…",2,[[["f64"],["usize"]],["self"]]],[11,"with_hashers","","Constructs a new, empty `BloomFilter` with an estimated…",2,[[["f64"],["usize"]],["self"]]],[11,"from_item_count_with_hashers","","Constructs a new, empty `BloomFilter` with `bit_count`…",2,[[["usize"]],["self"]]],[11,"from_fpp_with_hashers","","Constructs a new, empty `BloomFilter` with `bit_count`…",2,[[["f64"],["usize"]],["self"]]],[11,"insert","","Inserts an element into the bloom filter.",2,[[["self"],["u"]]]],[11,"contains","","Checks if an element is possibly in the bloom filter.",2,[[["self"],["u"]],["bool"]]],[11,"len","","Returns the number of bits in the bloom filter.",2,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the bloom filter is empty.",2,[[["self"]],["bool"]]],[11,"hasher_count","","Returns the number of hash functions used by the bloom…",2,[[["self"]],["usize"]]],[11,"clear","","Clears the bloom filter, removing all elements.",2,[[["self"]]]],[11,"count_ones","","Returns the number of set bits in the bloom filter.",2,[[["self"]],["usize"]]],[11,"count_zeros","","Returns the number of unset bits in the bloom filter.",2,[[["self"]],["usize"]]],[11,"estimated_fpp","","Returns the estimated false positive probability of the…",2,[[["self"]],["f64"]]],[11,"hashers","","Returns a reference to the bloom filter's hasher builders.",2,[[["self"]]]],[11,"new","","Constructs a new, empty `BSBloomFilter` with `bit_count`…",3,[[["f64"],["usize"]],["self"]]],[11,"with_hashers","","Constructs a new, empty `BSBloomFilter` with `bit_count`…",3,[[["f64"],["usize"]],["self"]]],[11,"insert","","Inserts an element into the bloom filter and returns if it…",3,[[["self"],["u"]]]],[11,"contains","","Checks if an element is possibly in the bloom filter.",3,[[["self"],["u"]],["bool"]]],[11,"len","","Returns the number of bits in the bloom filter.",3,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the bloom filter is empty.",3,[[["self"]],["bool"]]],[11,"bit_count","","Returns the number of bits in each partition in the bloom…",3,[[["self"]],["usize"]]],[11,"hasher_count","","Returns the number of hash functions used by the bloom…",3,[[["self"]],["usize"]]],[11,"clear","","Clears the bloom filter, removing all elements.",3,[[["self"]]]],[11,"count_ones","","Returns the number of set bits in the bloom filter.",3,[[["self"]],["usize"]]],[11,"count_zeros","","Returns the number of unset bits in the bloom filter.",3,[[["self"]],["usize"]]],[11,"hashers","","Returns a reference to the bloom filter's hasher builders.",3,[[["self"]]]],[11,"new","","Constructs a new, empty `BSSDBloomFilter` with `bit_count`…",4,[[["f64"],["usize"]],["self"]]],[11,"with_hashers","","Constructs a new, empty `BSSDBloomFilter` with `bit_count`…",4,[[["f64"],["usize"]],["self"]]],[11,"insert","","Inserts an element into the bloom filter and returns if it…",4,[[["self"],["u"]]]],[11,"contains","","Checks if an element is possibly in the bloom filter.",4,[[["self"],["u"]],["bool"]]],[11,"len","","Returns the number of bits in the bloom filter.",4,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the bloom filter is empty.",4,[[["self"]],["bool"]]],[11,"bit_count","","Returns the number of bits in each partition in the bloom…",4,[[["self"]],["usize"]]],[11,"hasher_count","","Returns the number of hash functions used by the bloom…",4,[[["self"]],["usize"]]],[11,"clear","","Clears the bloom filter, removing all elements.",4,[[["self"]]]],[11,"count_ones","","Returns the number of set bits in the bloom filter.",4,[[["self"]],["usize"]]],[11,"count_zeros","","Returns the number of unset bits in the bloom filter.",4,[[["self"]],["usize"]]],[11,"hashers","","Returns a reference to the bloom filter's hasher builders.",4,[[["self"]]]],[11,"new","","Constructs a new, empty `RLBSBloomFilter` with `bit_count`…",5,[[["f64"],["usize"]],["self"]]],[11,"with_hashers","","Constructs a new, empty `RLBSBloomFilter` with `bit_count`…",5,[[["f64"],["usize"]],["self"]]],[11,"insert","","Inserts an element into the bloom filter and returns if it…",5,[[["self"],["u"]]]],[11,"contains","","Checks if an element is possibly in the bloom filter.",5,[[["self"],["u"]],["bool"]]],[11,"len","","Returns the number of bits in the bloom filter.",5,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the bloom filter is empty.",5,[[["self"]],["bool"]]],[11,"bit_count","","Returns the number of bits in each partition in the bloom…",5,[[["self"]],["usize"]]],[11,"hasher_count","","Returns the number of hash functions used by the bloom…",5,[[["self"]],["usize"]]],[11,"clear","","Clears the bloom filter, removing all elements.",5,[[["self"]]]],[11,"count_ones","","Returns the number of set bits in the bloom filter.",5,[[["self"]],["usize"]]],[11,"count_zeros","","Returns the number of unset bits in the bloom filter.",5,[[["self"]],["usize"]]],[11,"hashers","","Returns a reference to the bloom filter's hasher builders.",5,[[["self"]]]],[11,"from_item_count","","Constructs a new, empty `PartitionedBloomFilter` with an…",6,[[["f64"],["usize"]],["self"]]],[11,"from_bit_count","","Constructs a new, empty `PartitionedBloomFilter` with…",6,[[["f64"],["usize"]],["self"]]],[11,"from_item_count_with_hashers","","Constructs a new, empty `PartitionedBloomFilter` with an…",6,[[["f64"],["usize"]],["self"]]],[11,"from_bit_count_with_hashers","","Constructs a new, empty `PartitionedBloomFilter` with…",6,[[["f64"],["usize"]],["self"]]],[11,"insert","","Inserts an element into the bloom filter.",6,[[["self"],["u"]]]],[11,"contains","","Checks if an element is possibly in the bloom filter.",6,[[["self"],["u"]],["bool"]]],[11,"len","","Returns the number of bits in the bloom filter.",6,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the bloom filter is empty.",6,[[["self"]],["bool"]]],[11,"bit_count","","Returns the number of bits in each partition in the bloom…",6,[[["self"]],["usize"]]],[11,"hasher_count","","Returns the number of hash functions used by the bloom…",6,[[["self"]],["usize"]]],[11,"clear","","Clears the bloom filter, removing all elements.",6,[[["self"]]]],[11,"count_ones","","Returns the number of set bits in the bloom filter.",6,[[["self"]],["usize"]]],[11,"count_zeros","","Returns the number of unset bits in the bloom filter.",6,[[["self"]],["usize"]]],[11,"estimated_fpp","","Returns the estimated false positive probability of the…",6,[[["self"]],["f64"]]],[11,"hashers","","Returns a reference to the bloom filter's hasher builders.",6,[[["self"]]]],[11,"new","","Constructs a new, empty `ScalableBloomFilter` with…",7,[[["f64"],["usize"]],["self"]]],[11,"with_hashers","","Constructs a new, empty `ScalableBloomFilter` with…",7,[[["f64"],["usize"]],["self"]]],[11,"insert","","Inserts an element into the scalable bloom filter.",7,[[["self"],["u"]]]],[11,"contains","","Checks if an element is possibly in the scalable bloom…",7,[[["self"],["u"]],["bool"]]],[11,"len","","Returns the number of bits in the scalable bloom filter.",7,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the scalable bloom filter is empty.",7,[[["self"]],["bool"]]],[11,"filter_count","","Returns the number of bloom filters used by the scalable…",7,[[["self"]],["usize"]]],[11,"clear","","Clears the scalable bloom filter, removing all elements.",7,[[["self"]]]],[11,"count_ones","","Returns the number of set bits in the scalable bloom filter.",7,[[["self"]],["usize"]]],[11,"count_zeros","","Returns the number of unset bits in the scalable bloom…",7,[[["self"]],["usize"]]],[11,"estimated_fpp","","Returns the estimated false positive probability of the…",7,[[["self"]],["f64"]]],[11,"hashers","","Returns a reference to the scalable cuckoo filter's hasher…",7,[[["self"]]]],[0,"count_min_sketch","probabilistic_collections","Space-efficient probabilistic data structure for…",null,null],[3,"CountMinStrategy","probabilistic_collections::count_min_sketch","A count strategy that uses the minimum value to estimate…",null,null],[3,"CountMeanStrategy","","A count strategy that uses the mean value to estimate the…",null,null],[3,"CountMedianBiasStrategy","","A count strategy that uses the median value after…",null,null],[3,"CountMinSketch","","A space-efficient probabilistic data structure that serves…",null,null],[3,"ItemValueIter","","An iterator that yields values corresponding to an item in…",null,null],[8,"CountStrategy","","Trait for types that have the logic for estimating the…",null,null],[10,"get_estimate","","Returns the estimated number of item occurrences given the…",8,[[["i64"],["usize"],["itemvalueiter"]],["i64"]]],[11,"new","","Constructs a new, empty `CountMinSketch` with a specific…",9,[[["usize"]],["self"]]],[11,"from_error","","Constructs a new, empty `CountMinSketch` with a upper…",9,[[["f64"]],["self"]]],[11,"with_hashers","","Constructs a new, empty `CountMinSketch` with a specific…",9,[[["usize"]],["self"]]],[11,"from_error_with_hashers","","Constructs a new, empty `CountMinSketch` with a upper…",9,[[["f64"]],["self"]]],[11,"add","","Inserts an element into the count-min sketch `value` times.",9,[[["i64"],["self"],["v"]]]],[11,"remove","","Removes an element from the count-min sketch `value` times.",9,[[["i64"],["self"],["v"]]]],[11,"count","","Returns the estimated number of times `item` is in the…",9,[[["v"],["self"]],["i64"]]],[11,"clear","","Clears all items from the count-min sketch.",9,[[["self"]]]],[11,"rows","","Returns the number of rows in the count-min sketch.",9,[[["self"]],["usize"]]],[11,"cols","","Returns the number of columns in the count-min sketch.",9,[[["self"]],["usize"]]],[11,"confidence","","Returns the approximate confidence of the count-min sketch.",9,[[["self"]],["f64"]]],[11,"error","","Returns the approximate error of the count-min sketch.",9,[[["self"]],["f64"]]],[11,"hashers","","Returns a reference to the count-min sketch's hasher…",9,[[["self"]]]],[0,"cuckoo","probabilistic_collections","Space-efficient probabilistic data structure for…",null,null],[3,"CuckooFilter","probabilistic_collections::cuckoo","A space-efficient probabilistic data structure to test for…",null,null],[3,"ScalableCuckooFilter","","A growable, space-efficient probabilistic data structure…",null,null],[11,"new","","Constructs a new, empty `CuckooFilter` with an estimated…",10,[[["usize"]],["self"]]],[11,"from_parameters","","Constructs a new, empty `CuckooFilter` with an estimated…",10,[[["usize"]],["self"]]],[11,"from_entries_per_index","","Constructs a new, empty `CuckooFilter` with an estimated…",10,[[["f64"],["usize"]],["self"]]],[11,"from_fingerprint_bit_count","","Constructs a new, empty `CuckooFilter` with an estimated…",10,[[["f64"],["usize"]],["self"]]],[11,"with_hashers","","Constructs a new, empty `CuckooFilter` with an estimated…",10,[[["usize"]],["self"]]],[11,"from_parameters_with_hashers","","Constructs a new, empty `CuckooFilter` with an estimated…",10,[[["usize"]],["self"]]],[11,"from_entries_per_index_with_hashers","","Constructs a new, empty `CuckooFilter` with an estimated…",10,[[["f64"],["usize"]],["self"]]],[11,"from_fingerprint_bit_count_with_hashers","","Constructs a new, empty `CuckooFilter` with an estimated…",10,[[["f64"],["usize"]],["self"]]],[11,"insert","","Inserts an element into the cuckoo filter.",10,[[["self"],["u"]]]],[11,"remove","","Removes an element from the cuckoo filter.",10,[[["self"],["u"]]]],[11,"contains","","Checks if an element is possibly in the cuckoo filter.",10,[[["self"],["u"]],["bool"]]],[11,"clear","","Clears the cuckoo filter, removing all elements.",10,[[["self"]]]],[11,"len","","Returns the number of occupied entries in the cuckoo…",10,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if there are no occupied entries in the…",10,[[["self"]],["bool"]]],[11,"capacity","","Returns the maximum capacity of the cuckoo filter. Items…",10,[[["self"]],["usize"]]],[11,"bucket_len","","Returns the length of each bucket in the cuckoo filter.",10,[[["self"]],["usize"]]],[11,"entries_per_index","","Returns the number of entries per index in the cuckoo…",10,[[["self"]],["usize"]]],[11,"extra_items_len","","Returns the number of items that could not be inserted…",10,[[["self"]],["usize"]]],[11,"is_nearly_full","","Returns `true` if there are any items that could not be…",10,[[["self"]],["bool"]]],[11,"fingerprint_bit_count","","Returns the number of bits in each item fingerprint.",10,[[["self"]],["usize"]]],[11,"estimated_fpp","","Returns the estimated false positive probability of the…",10,[[["self"]],["f64"]]],[11,"hashers","","Returns a reference to the cuckoo filter's hasher builders.",10,[[["self"]]]],[11,"new","","Constructs a new, empty `ScalableCuckooFilter` with an…",11,[[["f64"],["usize"]],["self"]]],[11,"from_entries_per_index","","Constructs a new, empty `ScalableCuckooFilter` with an…",11,[[["f64"],["usize"]],["self"]]],[11,"with_hashers","","Constructs a new, empty `ScalableCuckooFilter` with an…",11,[[["f64"],["usize"]],["self"]]],[11,"from_entries_per_index_with_hashers","","Constructs a new, empty `ScalableCuckooFilter` with an…",11,[[["f64"],["usize"]],["self"]]],[11,"insert","","Inserts an element into the scalable cuckoo filter.",11,[[["self"],["u"]]]],[11,"contains","","Checks if an element is possibly in the scalable cuckoo…",11,[[["self"],["u"]],["bool"]]],[11,"remove","","Removes an element from the scalable cuckoo filter.",11,[[["self"],["u"]]]],[11,"len","","Returns the number of occupied entries in the cuckoo filter.",11,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if there are no occupied entries in the…",11,[[["self"]],["bool"]]],[11,"capacity","","Returns the maximum capacity of the cuckoo filter. The…",11,[[["self"]],["usize"]]],[11,"entries_per_index","","Returns the number of entries per index in each filter.",11,[[["self"]],["usize"]]],[11,"filter_count","","Returns the number of cuckoo filters used by the scalable…",11,[[["self"]],["usize"]]],[11,"clear","","Clears the scalable cuckoo filter, removing all elements.",11,[[["self"]]]],[11,"estimated_fpp","","Returns the estimated false positive probability of the…",11,[[["self"]],["f64"]]],[11,"hashers","","Returns a reference to the scalable cuckoo filter's hasher…",11,[[["self"]]]],[0,"hyperloglog","probabilistic_collections","Space-efficient probabilistic data structure for…",null,null],[3,"HyperLogLog","probabilistic_collections::hyperloglog","A space-efficient probabilitic data structure to count the…",null,null],[11,"new","","Constructs a new, empty `HyperLogLog<T>` with a given…",12,[[["f64"]],["self"]]],[11,"with_hasher","","Constructs a new, empty `HyperLogLog<T>` with a given…",12,[[["f64"],["b"]],["self"]]],[11,"insert","","Inserts an item into the `HyperLogLog<T>`.",12,[[["self"],["u"]]]],[11,"merge","","Merges `self` with `other`.",12,[[["self"],["hyperloglog"]]]],[11,"len","","Returns the estimated number of distinct items in the…",12,[[["self"]],["f64"]]],[11,"is_empty","","Returns `true` is the `HyperLogLog<T>` is empty.",12,[[["self"]],["bool"]]],[11,"clear","","Clears the `HyperLogLog<T>`, removing all items.",12,[[["self"]]]],[11,"hasher","","Returns a reference to the HyperLogLog's hasher builder.",12,[[["self"]],["b"]]],[0,"quotient","probabilistic_collections","Space-efficient probabilistic data structure for…",null,null],[3,"QuotientFilter","probabilistic_collections::quotient","A space-efficient probabilistic data structure to test for…",null,null],[11,"new","","Constructs a new, empty `QuotientFilter` with the…",13,[[["u8"]],["self"]]],[11,"from_fpp","","Constructs a new, empty `QuotientFilter` that can store…",13,[[["f64"],["usize"]],["self"]]],[11,"with_hasher","","Constructs a new, empty `QuotientFilter` with the…",13,[[["b"],["u8"]],["self"]]],[11,"from_fpp_with_hasher","","Constructs a new, empty `QuotientFilter` that can store…",13,[[["f64"],["usize"],["b"]],["self"]]],[11,"insert","","Inserts an element into the quotient filter.",13,[[["self"],["u"]]]],[11,"contains","","Checks if an element is possibly in the quotient filter.",13,[[["self"],["u"]],["bool"]]],[11,"remove","","Removes an element from the quotient filter.",13,[[["self"],["u"]]]],[11,"clear","","Clears the quotient filter, removing all elements.",13,[[["self"]]]],[11,"len","","Returns the number of items in the quotient filter.",13,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the quotient filter is empty.",13,[[["self"]],["bool"]]],[11,"capacity","","Returns the capacity of the quotient filter.",13,[[["self"]],["usize"]]],[11,"quotient_bits","","Returns the number of quotient bits in a fingerprint for a…",13,[[["self"]],["u8"]]],[11,"remainder_bits","","Returns the number of remainder bits in a fingerprint for…",13,[[["self"]],["u8"]]],[11,"estimated_fpp","","Returns the estimated false positive probability of the…",13,[[["self"]],["f64"]]],[11,"hasher","","Returns a reference to the quotient filter's hasher builder.",13,[[["self"]],["b"]]],[0,"similarity","probabilistic_collections","Locality-sensitive hashing schemes for measuring…",null,null],[3,"MinHash","probabilistic_collections::similarity","`MinHash` is a locality sensitive hashing scheme that can…",null,null],[3,"SimHash","","`SimHash` is a locality sensitive hashing scheme. If two…",null,null],[3,"ShingleIterator","","A w-shingle iterator for an list of items.",null,null],[5,"get_jaccard_similarity","","Computes the Jaccard Similarity between two iterators. The…",null,[[["t"]],["f64"]]],[11,"new","","Constructs a new `MinHash` with a specified number of hash…",14,[[["usize"]],["self"]]],[11,"with_hashers","","Constructs a new `MinHash` with a specified number of hash…",14,[[["usize"]],["self"]]],[11,"get_min_hashes","","Returns the minimum hash values obtained from a specified…",14,[[["self"],["t"]],[["u64"],["vec",["u64"]]]]],[11,"get_similarity_from_hashes","","Returns the estimated Jaccard Similarity measure from the…",14,[[["self"]],["f64"]]],[11,"get_similarity","","Returns the estimated Jaccard Similarity measure from two…",14,[[["self"],["t"]],["f64"]]],[11,"hasher_count","","Returns the number of hash functions being used in…",14,[[["self"]],["usize"]]],[11,"hashers","","Returns a reference to the `MinHash`'s hasher builders.",14,[[["self"]]]],[11,"new","","Constructs a new `SimHash`.",15,[[],["self"]]],[11,"with_hasher","","Constructs a new `SimHash` with a specified hasher builder.",15,[[["b"]],["self"]]],[11,"get_sim_hash","","Returns the hash associated with iterator `iter`.",15,[[["self"],["t"]],["u64"]]],[11,"report_similarities","","Returns all pairs of indexes corresponding to iterators in…",15,[[["vec"],["self"],["usize"]],["vec"]]],[11,"hasher","","Returns a reference to the `SimHash`'s hasher builder.",15,[[["self"]],["b"]]],[11,"new","","Constructs a new `ShingleIterator` that contains shingles…",16,[[["vec"],["usize"],["t"]],["self"]]],[11,"from_entropy","probabilistic_collections","Constructs a new `SipHasherBuilder` that uses the…",17,[[],["self"]]],[11,"from_seed","","Constructs a new `SipHasherBuilder` that is seeded with…",17,[[["u64"]],["self"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,[[["self"],["t"]]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"vzip","","",17,[[],["v"]]],[11,"from","probabilistic_collections::bit_array_vec","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"into_iter","","",0,[[],["i"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"vzip","","",0,[[],["v"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"into_iter","","",18,[[],["i"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"vzip","","",18,[[],["v"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[],["u"]]],[11,"into_iter","","",19,[[],["i"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"type_id","","",19,[[["self"]],["typeid"]]],[11,"vzip","","",19,[[],["v"]]],[11,"from","probabilistic_collections::bit_vec","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"into_iter","","",1,[[],["i"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"vzip","","",1,[[],["v"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[],["u"]]],[11,"into_iter","","",20,[[],["i"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"type_id","","",20,[[["self"]],["typeid"]]],[11,"vzip","","",20,[[],["v"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[],["u"]]],[11,"into_iter","","",21,[[],["i"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"type_id","","",21,[[["self"]],["typeid"]]],[11,"vzip","","",21,[[],["v"]]],[11,"from","probabilistic_collections::bloom","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"vzip","","",2,[[],["v"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"vzip","","",3,[[],["v"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"vzip","","",4,[[],["v"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"vzip","","",5,[[],["v"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"vzip","","",6,[[],["v"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"vzip","","",7,[[],["v"]]],[11,"from","probabilistic_collections::count_min_sketch","",22,[[["t"]],["t"]]],[11,"into","","",22,[[],["u"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"type_id","","",22,[[["self"]],["typeid"]]],[11,"vzip","","",22,[[],["v"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"into","","",23,[[],["u"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"type_id","","",23,[[["self"]],["typeid"]]],[11,"vzip","","",23,[[],["v"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"into","","",24,[[],["u"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"type_id","","",24,[[["self"]],["typeid"]]],[11,"vzip","","",24,[[],["v"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"vzip","","",9,[[],["v"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"into","","",25,[[],["u"]]],[11,"into_iter","","",25,[[],["i"]]],[11,"to_owned","","",25,[[["self"]],["t"]]],[11,"clone_into","","",25,[[["self"],["t"]]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"type_id","","",25,[[["self"]],["typeid"]]],[11,"vzip","","",25,[[],["v"]]],[11,"from","probabilistic_collections::cuckoo","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"vzip","","",10,[[],["v"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"vzip","","",11,[[],["v"]]],[11,"from","probabilistic_collections::hyperloglog","",12,[[["t"]],["t"]]],[11,"into","","",12,[[],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"type_id","","",12,[[["self"]],["typeid"]]],[11,"vzip","","",12,[[],["v"]]],[11,"from","probabilistic_collections::quotient","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"vzip","","",13,[[],["v"]]],[11,"from","probabilistic_collections::similarity","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"vzip","","",14,[[],["v"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"vzip","","",15,[[],["v"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"into_iter","","",16,[[],["i"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"vzip","","",16,[[],["v"]]],[11,"get_estimate","probabilistic_collections::count_min_sketch","",22,[[["i64"],["usize"],["itemvalueiter"]],["i64"]]],[11,"get_estimate","","",23,[[["i64"],["usize"],["itemvalueiter"]],["i64"]]],[11,"get_estimate","","",24,[[["i64"],["usize"],["itemvalueiter"]],["i64"]]],[11,"into_iter","probabilistic_collections::bit_array_vec","",0,[[]]],[11,"into_iter","probabilistic_collections::bit_vec","",1,[[]]],[11,"next","probabilistic_collections::bit_array_vec","",18,[[["self"]],[["option",["vec"]],["vec",["u8"]]]]],[11,"next","","",19,[[["self"]],[["option",["vec"]],["vec",["u8"]]]]],[11,"next","probabilistic_collections::bit_vec","",20,[[["self"]],[["bool"],["option",["bool"]]]]],[11,"next","","",21,[[["self"]],[["bool"],["option",["bool"]]]]],[11,"next","probabilistic_collections::count_min_sketch","",25,[[["self"]],["option"]]],[11,"next","probabilistic_collections::similarity","",16,[[["self"]],["option"]]],[11,"clone","probabilistic_collections::bit_vec","",1,[[["self"]],["self"]]],[11,"clone_from","","",1,[[["self"],["self"]]]],[11,"clone","probabilistic_collections::count_min_sketch","",25,[[["self"]],["itemvalueiter"]]],[11,"clone","probabilistic_collections","",17,[[["self"]],["siphasherbuilder"]]],[11,"default","probabilistic_collections::similarity","",15,[[],["simhash"]]],[11,"eq","probabilistic_collections::bit_array_vec","",0,[[["bitarrayvec"],["self"]],["bool"]]],[11,"ne","","",0,[[["bitarrayvec"],["self"]],["bool"]]],[11,"eq","probabilistic_collections::bit_vec","",1,[[["self"],["bitvec"]],["bool"]]],[11,"ne","","",1,[[["self"],["bitvec"]],["bool"]]],[11,"eq","probabilistic_collections::bloom","",2,[[["self"],["bloomfilter"]],["bool"]]],[11,"ne","","",2,[[["self"],["bloomfilter"]],["bool"]]],[11,"eq","probabilistic_collections::cuckoo","",10,[[["self"],["cuckoofilter"]],["bool"]]],[11,"eq","probabilistic_collections","",17,[[["siphasherbuilder"],["self"]],["bool"]]],[11,"fmt","probabilistic_collections::bit_array_vec","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","probabilistic_collections::bit_vec","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","probabilistic_collections::bloom","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","probabilistic_collections::cuckoo","",10,[[["formatter"],["self"]],["result"]]],[11,"fmt","probabilistic_collections::quotient","",13,[[["formatter"],["self"]],["result"]]],[11,"fmt","probabilistic_collections","",17,[[["formatter"],["self"]],["result"]]],[11,"index","probabilistic_collections::bit_vec","",1,[[["self"],["usize"]],["bool"]]],[11,"build_hasher","probabilistic_collections","",17,[[["self"]],["siphasher"]]]],"p":[[3,"BitArrayVec"],[3,"BitVec"],[3,"BloomFilter"],[3,"BSBloomFilter"],[3,"BSSDBloomFilter"],[3,"RLBSBloomFilter"],[3,"PartitionedBloomFilter"],[3,"ScalableBloomFilter"],[8,"CountStrategy"],[3,"CountMinSketch"],[3,"CuckooFilter"],[3,"ScalableCuckooFilter"],[3,"HyperLogLog"],[3,"QuotientFilter"],[3,"MinHash"],[3,"SimHash"],[3,"ShingleIterator"],[3,"SipHasherBuilder"],[3,"BitArrayVecIter"],[3,"BitArrayVecIntoIter"],[3,"BitVecIter"],[3,"BitVecIntoIter"],[3,"CountMinStrategy"],[3,"CountMeanStrategy"],[3,"CountMedianBiasStrategy"],[3,"ItemValueIter"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);